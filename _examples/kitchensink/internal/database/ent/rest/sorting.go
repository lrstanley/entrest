// Code generated by ent, DO NOT EDIT.

package rest

import (
	"fmt"
	"slices"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/category"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/follows"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/friendship"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/pet"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/post"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/settings"
	"github.com/lrstanley/entrest/_examples/kitchensink/internal/database/ent/user"
)

type Sorted struct {
	// Field is the field to sort by. Can be a standard field name (e.g. "name"), or a custom field
	// name (e.g. "pets.age.sum"). If no field is provided, the default field will be used.
	Field *string `json:"sort" form:"sort,omitempty"`

	// Order is the order to sort by. Can be either "asc" or "desc". If no order is provided, the
	// default order will be used.
	Order *orderDirection `json:"order" form:"order,omitempty"`
}

// Validate validates the sorting fields and applies any necessary defaults.
func (s *Sorted) Validate(cfg *SortConfig) error {
	if s.Field == nil {
		if cfg.DefaultField == "" {
			return nil
		}
		s.Field = &cfg.DefaultField
	}
	if s.Order == nil {
		s.Order = &cfg.DefaultOrder
	}

	if !slices.Contains(cfg.Fields, *s.Field) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid sort field: %s", *s.Field)}
	}

	if !slices.Contains(OrderDirections, *s.Order) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid order: %s", *s.Order)}
	}

	return nil
}

// withOrderTerm returns the OrderTermOption (asc/desc) based on the provided order string.
func withOrderTerm(order orderDirection) sql.OrderTermOption {
	if order == orderAsc {
		return sql.OrderAsc()
	}
	return sql.OrderDesc()
}

func withFieldSelector(field string, order orderDirection) func(*sql.Selector) {
	if order == orderAsc {
		return ent.Asc(field)
	}
	return ent.Desc(field)
}

type SortConfig struct {
	Fields       []string
	DefaultField string
	DefaultOrder orderDirection
}

type orderDirection string

var (
	orderAsc  orderDirection = "asc"
	orderDesc orderDirection = "desc"

	// OrderDirections are the allowed order directions that can be provided.
	OrderDirections = []orderDirection{orderAsc, orderDesc}
	// CategorySortConfig defines the default sort configuration for Category.
	CategorySortConfig = &SortConfig{
		Fields: []string{
			"created_at",
			"id",
			"pets.age.sum",
			"pets.count",
			"random",
			"updated_at",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// FollowSortConfig defines the default sort configuration for Follow.
	FollowSortConfig = &SortConfig{
		Fields: []string{
			"followed_at",
			"pet.age",
			"pet.name",
			"random",
			"user.created_at",
			"user.email",
			"user.name",
			"user.updated_at",
		},
		DefaultOrder: "asc",
	}
	// FriendshipSortConfig defines the default sort configuration for Friendship.
	FriendshipSortConfig = &SortConfig{
		Fields: []string{
			"friend.created_at",
			"friend.email",
			"friend.name",
			"friend.updated_at",
			"friend_id",
			"id",
			"random",
			"user.created_at",
			"user.email",
			"user.name",
			"user.updated_at",
			"user_id",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// PetSortConfig defines the default sort configuration for Pet.
	PetSortConfig = &SortConfig{
		Fields: []string{
			"age",
			"categories.count",
			"followed_by.count",
			"following.count",
			"friends.age.sum",
			"friends.count",
			"id",
			"name",
			"owner.created_at",
			"owner.email",
			"owner.id",
			"owner.name",
			"owner.updated_at",
			"random",
		},
		DefaultField: "name",
		DefaultOrder: "asc",
	}
	// PostSortConfig defines the default sort configuration for Post.
	PostSortConfig = &SortConfig{
		Fields: []string{
			"author.created_at",
			"author.email",
			"author.id",
			"author.name",
			"author.updated_at",
			"created_at",
			"id",
			"random",
			"updated_at",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// SettingSortConfig defines the default sort configuration for Setting.
	SettingSortConfig = &SortConfig{
		Fields: []string{
			"admins.count",
			"created_at",
			"id",
			"random",
			"updated_at",
		},
		DefaultField: "id",
		DefaultOrder: "asc",
	}
	// UserSortConfig defines the default sort configuration for User.
	UserSortConfig = &SortConfig{
		Fields: []string{
			"created_at",
			"email",
			"followed_pets.age.sum",
			"followed_pets.count",
			"following.count",
			"friends.count",
			"friendships.count",
			"id",
			"name",
			"pets.age.sum",
			"pets.count",
			"posts.count",
			"random",
			"updated_at",
		},
		DefaultField: "name",
		DefaultOrder: "asc",
	}
)

// isSpecializedSort checks if the sort field is a specialized sort field.
func isSpecializedSort(parts []string) (isCount, isSum bool) {
	switch {
	case len(parts) == 3:
		switch parts[2] {
		case "count":
			isCount = true
		case "sum":
			isSum = true
		}
	case len(parts) == 2:
		switch parts[1] {
		case "count":
			isCount = true
		case "sum":
			isSum = true
		}
	}
	return isCount, isSum
}

// applySortingCategory applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingCategory(query *ent.CategoryQuery, field string, order orderDirection) *ent.CategoryQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case category.EdgePets:
			switch {
			case isCount:
				return query.Order(category.ByPetsCount(dir))
			case isSum:
				return query.Order(category.ByPets(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(category.ByPets(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingFollow applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingFollow(query *ent.FollowsQuery, field string, order orderDirection) *ent.FollowsQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case follows.EdgeUser:
			return query.Order(follows.ByUserField(parts[1], dir))
		case follows.EdgePet:
			return query.Order(follows.ByPetField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingFriendship applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingFriendship(query *ent.FriendshipQuery, field string, order orderDirection) *ent.FriendshipQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case friendship.EdgeUser:
			return query.Order(friendship.ByUserField(parts[1], dir))
		case friendship.EdgeFriend:
			return query.Order(friendship.ByFriendField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingPet applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingPet(query *ent.PetQuery, field string, order orderDirection) *ent.PetQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case pet.EdgeCategories:
			switch {
			case isCount:
				return query.Order(pet.ByCategoriesCount(dir))
			case isSum:
				return query.Order(pet.ByCategories(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(pet.ByCategories(sql.OrderByField(parts[1], dir)))
			}
		case pet.EdgeOwner:
			return query.Order(pet.ByOwnerField(parts[1], dir))
		case pet.EdgeFriends:
			switch {
			case isCount:
				return query.Order(pet.ByFriendsCount(dir))
			case isSum:
				return query.Order(pet.ByFriends(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(pet.ByFriends(sql.OrderByField(parts[1], dir)))
			}
		case pet.EdgeFollowedBy:
			switch {
			case isCount:
				return query.Order(pet.ByFollowedByCount(dir))
			case isSum:
				return query.Order(pet.ByFollowedBy(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(pet.ByFollowedBy(sql.OrderByField(parts[1], dir)))
			}
		case pet.EdgeFollowing:
			switch {
			case isCount:
				return query.Order(pet.ByFollowingCount(dir))
			case isSum:
				return query.Order(pet.ByFollowing(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(pet.ByFollowing(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingPost applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingPost(query *ent.PostQuery, field string, order orderDirection) *ent.PostQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		switch parts[0] {
		case post.EdgeAuthor:
			return query.Order(post.ByAuthorField(parts[1], dir))
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingSetting applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingSetting(query *ent.SettingsQuery, field string, order orderDirection) *ent.SettingsQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case settings.EdgeAdmins:
			switch {
			case isCount:
				return query.Order(settings.ByAdminsCount(dir))
			case isSum:
				return query.Order(settings.ByAdmins(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(settings.ByAdmins(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}

// applySortingUser applies sorting to the query based on the provided sort and
// order fields. Note that all inputs provided MUST ALREADY BE VALIDATED.
func applySortingUser(query *ent.UserQuery, field string, order orderDirection) *ent.UserQuery {
	if parts := strings.Split(field, "."); len(parts) > 1 {
		dir := withOrderTerm(order)

		isCount, isSum := isSpecializedSort(parts)

		switch parts[0] {
		case user.EdgePets:
			switch {
			case isCount:
				return query.Order(user.ByPetsCount(dir))
			case isSum:
				return query.Order(user.ByPets(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByPets(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgeFollowedPets:
			switch {
			case isCount:
				return query.Order(user.ByFollowedPetsCount(dir))
			case isSum:
				return query.Order(user.ByFollowedPets(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByFollowedPets(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgeFriends:
			switch {
			case isCount:
				return query.Order(user.ByFriendsCount(dir))
			case isSum:
				return query.Order(user.ByFriends(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByFriends(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgePosts:
			switch {
			case isCount:
				return query.Order(user.ByPostsCount(dir))
			case isSum:
				return query.Order(user.ByPosts(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByPosts(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgeFollowing:
			switch {
			case isCount:
				return query.Order(user.ByFollowingCount(dir))
			case isSum:
				return query.Order(user.ByFollowing(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByFollowing(sql.OrderByField(parts[1], dir)))
			}
		case user.EdgeFriendships:
			switch {
			case isCount:
				return query.Order(user.ByFriendshipsCount(dir))
			case isSum:
				return query.Order(user.ByFriendships(sql.OrderBySum(parts[1], dir)))
			default:
				return query.Order(user.ByFriendships(sql.OrderByField(parts[1], dir)))
			}
		}
	}
	if field == "random" {
		return query.Order(sql.OrderByRand())
	}
	return query.Order(withFieldSelector(field, order))
}
